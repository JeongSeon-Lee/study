< 08 - 2, 문자를 저장하는 배열 >
1. char형 배열은 문자들을 메모리의 연속된 공간에 저장할 수 있으므로 주로 문자열을 저장하는 용도로 쓰입니다.
2. char형 배열은 문자열을 저장하는 변숭의 역할을 하는 것으로 문자열로 직접 초기화할 수 있다.
3. 모든 알파벳 문자는 한 바이트로 충분히 표현할 수 있으니 char배열을 사용하는 것이 좋습니다.
4. 대입 연산자 왼쪽에 사용한 배열명이 컴파일 과정에서 배열이 할당된 메모리의 주소 값으로 바뀌기 때문에 배열에 대입 연산자를 사용할 수 없다.
5. strcpy 함수는 그 위치로 이동하여 메모리의 공간을 사용하도록 구현되어 있기 때문이다.
6. gets 함수는 한 줄 입력, scanf 함수는 하나의 단어만 입력
7. puts 함수는 문자열 출력 후 줄 바꿈

< 09 - 1, 포인터의 기본 개념>
1. 포인터, 메모리의 주소
2. 주소 연산자, 변수의 주소 알기, 주소라 하면 변수가 할당된 메모리 공간의 시작 주소

< 09 - 2, 포인터 완전 정복을 위한 포인터 이해하기>
1. 포인터에 주소를 저장할 때는 가리키는 자료형이 같아야 한다.

< 10 - 1, 배열과 포인터의 관계>
1. 배열명은 첫 번째 요소의 주소이다.
2. 포인터에 배열명을 저장하면 포인터를 배열명처럼 사용할 수 있다.
3. 배열명의 정수 덧셈은 가리키는 자료형의 크기를 곱해서 더한다.
4. 포인터의 뺄셈 결과는 배열 요소 간의 간격 차이를 의미한다.

< 11 - 1, 아스키 코드 값과 문자 입출력 함수>
1. 프로그램이 처리할 데이터는 대부분 문자열입니다. 연산을 위한 값도 숫자 형태의 문자열을 변환하여 처리하므로 문자열을 제대로 다루는 것은 데이터 처리의 기본입니다.
2. 모든 문자 상수는 아스키 코드 값으로 바뀌어 숫자로 저장되고 연산된다.
3. 화이트 스페이스는 %d, %lf, %s와 같은 변환 문자로 숫자나 문자열을 입력할 때는 데이터를 구분하는 용도로 쓰이며, 그 자체가 데이터로 입력되지는 않습니다.
4. 다만, %c 변환 문자는 화이트 스페이스도 입력합니다.
5. scanf 함수는 %c 앞에 화이트 스페이스를 사용하면 문자도 분리하여 입력할 수 있는 특별한 기능이 있습니다.
6. 문자 전용 입출력 함수 : int getchar(void); 키보드로 입력한 문자의 아스키 코드 값을 반환합니다.
7. 문자 전용 입출력 함수 : int putchar(int); 문자 상수나 문자의 아스키 코드 값을 인수로 주면 해당 문자를 화면에 출력합니다.

< 11 - 2, 버퍼를 사용하는 입력 함수>
1. scanf 함수가 데이터를 입력할 때는 가장 먼저 버퍼의 상태를 확인한다.
2. 버퍼에 저장되는 데이터의 끝에는 항상 개행 문자가 있다.
3. 개행 문자 또한 하나의 입력 데이터로 쓴다면 입력을 종료하는 별도의 신호가 필요합니다. 이때 scanf 함수의 반환값을 사용합니다.
4. scanf 함수는 키보드로 Ctrl + z를 누르면 -1(EOF)를 반환합니다. 
5. 키보드로 숫자를 입력하는 경우에도 일단 문자열의 형태로 버퍼에 저장됩니다.
6. 각각 아스키 코드 값으로 코드화되어 버퍼에 저장되고, 변환 문자의 지시에 따라 연산이 가능한 숫자로 변환되어 변수에 저장됩니다.

< 12 - 1, 문자열과 포인터>
1. 문자열은 배열의 구조로 쓰이며 첫 번째 문자의 주소로 쓰인다. 문자열은 주소다.

문자열은 컴파일 과정에서 char 배열 형태로 별도로 보관되고 문자열 상수가 있던 곳에 배열의 위치 값(첫 번째 문자의 주소)으로 바뀌므로 결국 포인터에는 문자열의 시작 위치 값만 저장된다.
그러나 포인터 연산을 통해 얼마든지 해당 문자열 전체를 사용할 수 있다.
printf 함수의 %s 변환 문자는 포인터 연산으로 문자열을 출력한다.
dessert의 값을 증가시키면서 널 문자가 나올 때까지 문자를 출력하면 결국 문자열 전체를 출력할 수 있습니다.

문자열을 주소로 바꾸면 포인터 연산을 통해 문자열의 시작 위치부터 길이 제한 없이 사용할 수 있다. 이 경우 문자열의 끝을 알아야 하므로 문자열의 끝을 표시하기 위해 널 문자를 사용한다. 따라서 컴파일러는 문자열 상수를 따로 저장할 때 마지막에 항상 널 문자를 붙여준다.

2. scanf 함수를 사용한 문자열 입력 : 공백 문자 전까지의 문자열을 배열에 저장하고 널 문자를 붙입니다.
3. char *gets(char *str); 버퍼에서 개행 문자를 가져오지만 배열에는 널 문자로 바꿔 저장합니다. 그래서 엔터만 눌러도 입력을 받습니다.
3. fgets(str, sizeof(str), stdin); 개행 문자까지 배열에 저장하고 마지막에 널 문자를 붙입니다.
4. 표준 입력 함수의 버퍼 공유 문제 : getchar(); scanf("%c"); fgetc(stdin);
5. int puts(const char *str); 문자열을 출력하고 자동 줄 바꿈
6. int fputs(const char *str, FILE *stream); 문자열을 출력하고 줄 바꾸지 않음

< 12 - 2, 문자열 연산 함수>
1. strcpy, strncpy
2. strcat, strncat
3. strlen
4. strcmp, strncmp

< 13 - 1, 변수 사용 영역>
1. auto 지역 변수
2. resister 지역 변수
3. static 지역 변수
4. 전역 변수
5. static 전역 변수

< 13 - 2, 함수의 데이터 공유 방법>
1. 여러 가지 데이터 공유 방법
2. 값을 넘겨준다.
3. 값을 반환받는다.
4. 주소를 넘겨준다.
5. 주소를 반환받는다. ex) int *p;
6. C 언어에는 call by reference를 구현하는 문법 형식이 없습니다. 다만 주소를 함수의 인수로 주고 포인터로 받아 간접 참조 연산을 통해 call by reference와 비슷한 효과를 낼 수 있습니다.
7. 결국 이 방법도 주소 값을 주고받으므로 call by value입니다.

< 14 - 1, 다차원 배열>
1. 2차원 배열은 1차원 배열을 요소로 갖는 배열
2. 2차원 배열은 논리적으로는 행렬의 구조를 가지고 있지만 물리적으로는 1차원 배열의 형태로 메모리에 할당됩니다.
3. 첫 번재 괄호 안의 숫자는 배열 요소의 수가 되고, 두 번째 괄호 안의 숫자는 배열 요소의 형태를 나타냅니다.
4. 2차원 배열은 1차원 배열을 부분배열로 가짐
5. 2차원 char 배열 : 하나의 문자열을 저장하기 위해서는 1차원 char 배열이 필요하고 여러 개의 문자열을 저장하려면 1차원 char 배열이 여러 개 필요합니다.
6. 3차원 배열에서는 2차원 배열이 부분배열이 되며 그 부분배열은 다시 1차원 부분배열들로 구성됩니다.
7. 3차원 배열은 논리적으로 면, 행, 열의 구조
8. 면부분배열, 행부분배열

< 14 - 2, 포인터 배열>
1. 포인터는 주소를 저장하는 특별한 용도로 쓰이지만, 일반 변수처럼 메모리에 저장 공간을 갖는 변수이다.
2. 포인터 배열은 1차원 배열이나 포인터 연산을 통해 2차원 배열처럼 쓸 수 있습니다.
3. 포인터는 자신이 가리키는 변수의 형태를 알고 있으므로 정수 연산을 통해 원하는 위치를 찾아갈 수 있습니다.